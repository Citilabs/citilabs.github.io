{
  "name": "Citilabs",
  "tagline": "",
  "body": "### Welcome to the Citilabs GitHub page.\r\nHere you will find information on open source projects provided by Citilabs.\r\n\r\n### OMXLib\r\nCitilabs is proud to present our Cube OMX library implementation and specification to the community. Starting with Cube 6.4.2, Cube provides support for reading and writing Cube OMX files. This section provides some detailed information about the library.\r\n\r\nOMXLib is a complete implementation of the specification described in [this](CubeOMX_0.3.pdf). The library is written in C++ and fully implements the specification. However, OMXLib may be utilized from a variety of programming languages. We provide API wrappers that allow the C++ compiled binaries to be utilized directly by languages and frameworks such as Python, Java, C#/.NET, and potentially many others. \r\n\r\nThis is a key benefit of OMXLib, there is no need for any other implementation and there is no worry as to whether an implementation from one organization written for a particular language will be compatible with or have the same performance or other behavior as one from another organization, since the primary OMXLib library is written in a single code-base, with API wrappers, which essentially act as a \"front-end,\" for other languages such as Java, Python, etc.\r\n\r\nOMXLib is also a very intuitive API. Great care was taken to properly hide the user from specific implementation details such as the backing data-store; this means that users of the API do not need to know or use any HDF5 specific functions. The API encapsulates those details and the public header files do not introduce unnecessary dependencies (utilizing the PIMPL idiom, for C++ aficionados). OMXLib provides a variety of facilities for inspecting aspects of an HDF5 file such as what matrices or zonal references, the number of zones, the data compression levels, attributes, and many others. The Cube OMX specification also provides built-in facilities for supporting feature-detection and seamless extensibility (via the OMX_CAPABILITIES attribute). The OMXLib API wrappers also attempt to provide a straight-forward interface to the library, while maintaining high performance. That is, native data buffers are utilized rather than language or framework specific data types that may have performance pitfalls. For instance, to utilize OMXLib from C#, you do not create a two-dimensional C# array or anything like that, the library provides a mechanism for allocating and disposing native data buffers, which eliminates performance problems due to cache misses or other framework specific details.\r\n\r\nThe C++ project provides a simple test utility called \"omxbench,\" which may be used either as a simple way to verify it's performance or as a programming example. The method names in the public C++ headers largely match those in the API wrappers (i.e. the C++ library has a method called getZonalReferences() and the Python wrapper has a method with the exact same name).\r\n\r\nHere is an example writing a simple OMX file with one matrix.\r\n\r\n    f = omx.OmxFile(\"test.omx\")\r\n\r\n\t# set this OMX file to have 1000 zones\r\n    f.openWithTruncate(1000)\r\n\t# by default, the matrix data type will be Double, if one is not specified\r\n    matrix = f.addMatrix(\"firstMatrix\")\r\n\t\r\n\t# get a native buffer for row data\r\n    matrixDataRow = omx.OmxDoubleArray(zones)\r\n\r\n\t# we will write incrementing integers into the matrix\r\n\tv = 1\r\n    for i in range(zones):\r\n        # populating the list that will be used to write to a zonal reference\r\n        for j in range(zones):\r\n            matrixDataRow[j] = random.random() * 100000\r\n\t\t\tv += 1\r\n\t\t\t\r\n\t\t# write the data row to the file\r\n\t\tm.writeRow(i, matrixDataRow)\r\n\r\n\t# close the file\r\n\tf.close()\r\n\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}